 											THREADS
-> Thread is a sub process which can execute task independently.	
-> Task : smallest unit of work
	ex : printing number is a task
-> process execute thread and thread execute tasks 
-> JVM will create a thread which is called main thread which is rsponsible to execute main method	
-> when multiple threads are there then we can not prdict the execution

**HOW TO CREATE THREADS?
	-> there are 2 ways to create thread
		1. Using Thread class
		2. Using Runnable interface		
-> when we use/extends Thread but not call using start() in-state if we call using run() then it will not consider as a thread because when we call start()
   that particular thread will schedule in thread scheduler 
   
-> getName() :- it used to get curentThread name
				ex :- Thread.currentThread().getName();
-> join() :- it use to complete the current thread until the thread fully complete it wont got further once thread fully done with 
             execute then it will go with next thread.in simple term it is joining current thread with other thread.
             ex :- Cook t1 = new Cook();
             	   t1.start();
             	   t1.join();
-> yield() :- like join but not same it will give chance to other 

**THREAD LIFE CYCLE**
-> NEW -> RUNNABLE -> RUNNING -> SLEEP(4000)-> BLOCKING -> WAITING/TIMED-WAITING -> RUNNABLE -> RUNNING -> TERMINATE  
-> Thread t1 = new Thread(object) NEW thread will create
-> after creating the thread then when we call start() it will go to RUNNABLE state
-> Once thread gets CPU time, it will move from RUNNABLE to RUNNING.
-> Once run method's execution is over/completed thread moves to TERMINATED state.

-> if there is SLEEP state then that thread will go to WAITING/TIMED_WAITING stage.
-> once SLEEP time over then again it will go to RUNNABLE state then as per schedule will go to RUNNING
-> once completed RUNNING then thread will TERMINATE and one thread is terminated then restart is not 
   possible if restart then "illegalThreadStartException" will give.
-> In thread we can not predict the output because which ever task get first CPU time that one will execute first

**SYNCHRONIZATION**
-> synchronization will execute one thread at a time on one object. it will done by "object lock".
-> synchronization works on the concept of object locking
-> every object have one object lock
-> for this we have to use synchronized keyword in method signature then only synchronization will apply 
-> every class also have one class lock in case of static we can use class lock
-> releasing lock getting lock everything done by JVM

**ReEntrant Lock**
-> using this we can lock manually and achieve synchronization.it is a class which implements Lock interface.
-> it is advance way of locking.
-> locking and unlocking done using lock() and unlock()
-> inside lock() and unlock() what ever boiler plate present that is single threaded
-> if we do not use unlock() after work finish then thread will go to dead lock condition
 
 
**wait() vs sleep() and notify()**
-> wait() will release the lock but sleep() will not release the lock.
-> wait() is called from synchronized block.
-> for inter-thread communication we use wait() and notify().
-> wait() and notify() are in object class because we call on objects thats why it is in Object class.

** Executor Framework**
-> it is another way of creating Thread
-> it is added in java 1.5/5
->type of thread pool in executor service are fixed, dynamic, single.
	1. create Executor object
		ex :- ExecutorService service = Executors.newFixedThreadPool(5);
		
		newFixedThreadPool() -> fixed number of threads
		newSingleThreadExecutor() -> single thread
		newCashedThreadPool() -> dynamic thread
		

-> common functonalities pre-implemented i.e framework

**Callable interface**
-> using this also we can create thread. it is a interface.
-> when we use Callable then we have to override call() method and this method have return type not like run() method which does not have return type.
   as per need or return type the future object can return.
Q. Runnable vs Callable
Q. what is future object
Q. execute() vs submit() -> execute() works only in runnable but submit works on both runnable and callable





  	    											