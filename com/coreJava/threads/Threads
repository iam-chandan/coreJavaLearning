 											THREADS
-> Thread is a sub process which can execute task independently.	
-> Task : smallest unit of work
	ex : printing number is a task
-> process execute thread and thread execute tasks 
-> JVM will create a thread which is called main thread which is rsponsible to execute main method	
-> when multiple threads are there then we can not prdict the execution

**HOW TO CREATE THREADS?
	-> there are 2 ways to create thread
		1. Using Thread class
		2. Using Runnable interface		
-> when we use/extends Thread but not call using start() in-state if we call using run() then it will not consider as a thread because when we call start()
   that particular thread will schedule in thread scheduler 
   
-> getName() :- it used to get curentThread name
				ex :- Thread.currentThread().getName();
-> join() :- it use to complete the current thread until the thread fully complete it wont got further once thread fully done with 
             execuate then it will go with next thread.in simple term it is joining current thread with other thread.
             ex :- Cook t1 = new Cook();
             	   t1.start();
             	   t1.join();
-> yield() :- like join but not same it will give chance to other 

**THREAD LIFE CYCLE**
-> NEW -> RUNNABLE -> RUNNING -> SLEEP(4000)-> BLOCKING -> WAITING/TIMED-WAITING -> RUNNABLE -> RUNNING -> TERMINATE  
-> Thread t1 = new Thread(object) NEW thread will create
-> after creating the thread then when we call start() it will go to RUNNABLE state
-> Once thread gets CPU time, it will move from RUNNABLE to RUNNING.
-> Once run method's execution is over/completed thread moves to TERMINATED state.

-> if there is SLEEP state then that thread will go to WAITING/TIMED_WAITING stage.
-> once SLEEP time over then again it will go to RUNNABLE state then as per schedule will go to RUNNING
-> once completed RUNNING then thread will TERMINATE and one thread is terminated then restart is not 
   possible if restart then "illegalThreadStartException" will give.
-> In thread we can not predict the output because which ever task get first CPU time that one will execute first

**SYNCHRONIZATION**
-> synchronization will execute one thread at a time on one object. it will done by "object lock".
-> synchronization works on the concept of object locking
-> every object have one object lock
-> for this we have to use synchronized keyword in method signature then only synchronization will apply 
-> every class also have one class lcok in case of static we can use class lock
 
 
            	    											